## 1. 파일과 디렉터리

**`파일`  `확장자`  `속성`  `디렉터리`  `경로`  `절대 경로`  `상대 경로`**

<aside>

파일과 디렉터리는 보조기억장치에 있는 데이터 덩어리

운영체제는 어떻게 데이터 덩어리를 파일과 디렉터리로 관리할까?

</aside>

### 파일

> 하드 디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 집합
> 
- 이름, 파일을 실행하기 위한 정보, 파일 관련 부가 정보를 포함
- 파일 관련 부가 정보를 속성 또는 메타데이터라고 부름

![alt text](<image/15-1.png>)

- 파일 속성과 유형

![alt text](<image/15-2.png>) ![alt text](<image/15-3.png>)

### 디렉터리 (폴더)

> 파일들을 일목요연하게 관리하기 위해 이용하는 것
윈도우 운영체에서는 디렉터리를 폴더라고 부름
> 
- 1단계 디렉터리 : 모든 파일이 하나의 디렉터리 아래에 있는 경우
- 트리 구조 디렉터리 : 여러 계층을 가진 경우
- 루트 디렉터리 : 최상위 디렉터리, 슬래시(/)로 표현
    - 윈도우 운영체제에서는 흔히 C:\로 표현

![alt text](<image/15-4.png>)

### 경로

> 디렉터리를 이용해 파일 위치, 파일 이름을 특정 짓는 정보
> 
- 절대 경로 : 루트 디렉터리에서 자기 자신까지 이르는 고유한 경로
- 상대 경로 : 현재 디렉터리부터 시작하는 경로
- `.` : 현재 작업 디렉터리
- `..` : 현재 작업 디렉터리의 상위 디렉터리

### 디렉터리 엔트리

- 많은 운영체제에서는 디렉터리를 그저 특별한 형태의 파일로 간주
- 파일이 내부에 해당 파일과 관련되 정보를 담고 있다면, 디렉터리는 내부에 해당 디렉터리에 담겨 있는 대상과 관련된 정보를 담고 있음
- 디렉터리는 보조기억장치에 테이블(표) 형태의 정보로 저장
- 다양한 파일 시스템에서 디렉터리 엔트리(행)이 공통으로 포함하는 정보는 디렉터리에 포함된 대상의 이름과 그 대상이 보조기억장치 내에 저장된 위치를 유추할 수 있는 정보

## 2. 페이징을 통한 가상 메모리 관리

**`파티셔닝`  `포매팅`  `연속 할당`  `연결 할당`  `색인 할당`  `FAT 파일 시스템`  `유닉스 파일 시스템`**

<aside>

사용된 적이 없는 하드 디스크 또는 SSD의 보조기억장치에 곧바로 파일을 생성하거나 저장할 수 없음

보조기억장치를 사용하려면 파티셔닝과 포매팅을 거쳐야 함

</aside>

### 파티셔닝

> 저장 장치의 논리적인 영역을 구획하는 작업
파티션을 나누는 작업
> 
- 파티션 : 파티셔닝 작업을 통해 나누어진 영역 하나하나
- 윈도우 '하드 디스크 파티션 만들기 및 포맷'에서 컴퓨터 내의 보조기억장치가 어떻게 파티셔닝되어 운영되는지 확인 가능

![alt text](<image/15-5.png>)

### 포매팅

> 포맷하는 작업
파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업
> 
- 저장 장치를 완전히 삭제하는 것이라고 보기는 어려움
- 포매팅을 할 때 파일 시스템이 결정됨

![alt text](<image/15-6.png>)

### 파일 할당 방법

- 운영체제는 파일과 디렉터리를 블록 단위로 읽고 씀
- 하나의 파일이 보조기억장치에 저장될 때는 하나 이상의 블록에 걸쳐 저장
- 하드디스크의 가장 작은 저장 단위는 섹터이지만, 운영체제는 하나 이상의 섹터를 블록이라는 단위로 묶은 뒤 블록 단위로 파일과 디렉터리를 관리
- 연속 할당, 불연속 할당(연결 할당, 색인 할당)이 존재

![alt text](<image/15-7.png>)

### 1. 연속 할당

> 파일이 저장 장치 내에서 연속적인 공간을 차지하도록 블록을 할당하는 방법
> 
- 연속 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 첫 번째 블록 주소와 블록 단위의 길이를 명시
- 장점
    - 구현이 단순
- 단점
    - 외부 단편화를 야기함

![alt text](<image/15-8.png>)

### 2. 연결 할당

> 각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방법
> 
- 파일을 이루는 데이터를 연결 리스트로 관리
- 불연속 할당의 일종이기에 파일이 여러 블록에 흩어져 저장되어도 무방
- 마지막 블록에는 다음 블록이 없다는 특별한 표시자를 기록 (교재에서는 -1을 이용)
- 장점
    - 외부 단편화 문제 해결 가능
- 단점
    1. 반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 함
        - 파일 내 임의의 위치에 접근하는 속도, 즉 임의 접근 속도가 매우 느림
    2. 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록에 접근할 수 없음

![alt text](<image/15-9.png>)

### 3. 색인 할당

> 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방법
> 
- 색인 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 색인 블록 주소를 명시
- 장점
    - 연결 할당과 달리 파일 내 임의의 위치에 접근하기 쉬움
        - 파일의 i번째 데이터 블록에 접근하고 싶다면 색인 블록의 i번째 항목이 가리키는 블록에 접근하면 됨

![alt text](<image/15-10.png>)

### 파일 시스템

- USB 메모리, SD 카드 등의 저용량 저장 장치에서 사용되는 FAT 파일 시스템
- 유닉스 계열 운영체제에서 사용되는 유닉스 파일 시스템

### 1. FAT 파일 시스템

> 연결 할당의 단점을 보완한 파일 시스템
> 
- 파일 할당 테이블에 각 블록에 포함된 다음 블록의 주소들을 한데 모아 관리
- 디렉터리 엔트리에는 파일 이름과 파일의 첫 번째 블록 주소가 명시
- FAT 파일 시스템에서 FAT는 파티션의 앞부분에 만들어짐
- FAT가 메모리에 적재된 채 실행되면 기존 연결 할당보다 다음 블록을 찾는 속도가 매우 빨라지고 임의 접근에도 유리해짐

- ex) 아래와 같은 구조를 이루는 FAT 파일 시스템에서 /home/minchul/a.sh 파일을 읽는 과정
    1. 루트 디렉터리에서 home은 3번 블록에 존재
    2. 3번 블록을 읽어 home 디렉터리의 내용을 살펴보면 minchul은 15번 블록에 존재
    3. 15번 블록을 읽어 minchul 디렉터리의 내용을 살펴보면 a.sh 파일의 첫 번째 블록 주소가 9번
    4. FAT를 보면 a.sh파일은 9번, 8번, 11번, 13번 블록 순서로 저장되어 있다는 것을 알 수 있음
        
        즉, 파일 시스템은 /home/minchul/a.sh을 읽기 위해 9번, 8번, 11번, 13번 블록에 접근

        ![alt text](<image/15-11.png>)

### 2. 유닉스 파일 시스템

> 색인 할당을 기반으로 한 파일 시스템
> 
- 유닉스 파일 시스템에서는 색인 블록을 i-node라고 부름
- i-node에는 파일 속성 정보와 열다섯 개의 블록 주소가 저장될 수 있음
- 유닉스 파일 시스템의 디렉터리 엔트리는 파일 이름과 i-node 번호로 구성
- 파일 하나가 15개 이상의 블록을 차지하는 경우의 문제를 아래와 같이 해결
    1. 블록 주소 중 열두 개에는 직접 블록 주소를 저장
        - 직접 블록 : 파일 데이터가 저장된 블록
    2. 1번으로 충분하지 않다면 열세 번재 주소에 단일 간접 블록 주소를 저장
        - 단일 간접 블록 : 파일 데이터를 저장한 블록 주소가 저장된 블록
    3. 2번으로 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장
        - 이중 간접 블록 : 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록 (단일 간접 블록들의 주소를 저장하는 블록)
    4. 3번으로 충분하지 않다면 열다섯 번째 주소에 삼중 간접 블록 주소를 저장
        1. 삼중 간접 블록 : 이중 간접 블록의 주소가 저장된 븝록
            
            ![alt text](<image/15-12.png>)

- ex) 아래와 같은 구조를 이루는 유닉스 파일 시스템에서 /home/minchul/a.sh 파일을 읽는 과정 (간략한 설명을 위해 i-node에 파일 속성은 제외하고 블록 주소만 명시)
    1. 2번 i-node에 접근하여 루트 디렉터리가 1번 블록에 있다는 것을 파악 (유닉스 파일 시스템은 루트 디렉터리의 i-node를 항상 기억)
    2. 1번 블록을 읽어 루트 디렉터리의 내용을 살펴보면 home 디렉터리의 i-node는 3번
    3. 3번 i-node에 접근하여 home 디렉터리가 210번 블록에 있다는 것을 파악
    4. 210번 블록을 읽어 home 디렉터리의 내용을 살펴보면 minchul 디렉터리의 i-node는 8번
    5. 8번 i-node에 접근하여 minchul 디렉터리가 121번 블록에 있다는 것을 파악
    6. 121번 블록을 읽어 minchul 디렉터리의 내용을 살펴보면 a.sh의 i-node는 9번
    7. 9번 i-node에 접근하여 a.sh 파일이 98, 12, 13번 블록에 있다는 것을 파악
        
        즉, 파일 시스템은 /home/minchul/a.sh을 읽기 위해 98번, 12번, 13번 블록에 접근

        ![alt text](<image/15-13.png>)
