## 1. 연속 메모리 할당

**`스와핑`  `최초 적합`  `최적 적합`  `최악 적합`  `외부 단편화`**

### 스와핑

> 현재 실행되지 않는 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 생긴 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식
> 
- 스왑 영역 : 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인 : 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

<aside>

스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행 가능

</aside>

### 연속 메모리 할당 방식

> 프로세스에 연속적인 메모리 공간을 할당하는 방식
> 
1. 최초 적합 
    - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 **발견하면** 그 공간에 프로세스를 배치하는 방식
    - 검색을 최소화할 수 있고 결과적으로 빠른 할당이 가능
2. 최적 적합
    - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 **가장 작은 공간**에 프로세스를 배치하는 방식
3. 최악 적합
    - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 **가장 큰 공간**에 프로세스를 배치하는 방식

<aside>

연속 메모리 할당은 외부 단편화 문제를 내포하고 있기 때문에 메모리를 효율적으로 사용하는 방법이 아님

</aside>

### 외부 단편화

> 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
> 

### 압축 (메모리 조각 모음)

> 외부 단편화를 해결할 수 있는 대표적인 방안
메모리 내에 저장된 프로세스들을 적당히 재배치시켜 흩어져 있는 작은 빈 공간을 하나로 모으는 방식
> 
- 단점
    - 빈 공간을 하나로 모으는 동안 시스템이 하던 일을 중지해야 함
    - 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기
        - 오버헤드 : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리 등
    - 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지 명확히 결정하기 어려움

<aside>

이러한 단점으로 인해 새로 등장한 해결 방안이 가장 메모리 기법, 그 중에서도 페이징 기법

</aside>

## 2. 페이징을 통한 가상 메모리 관리

**`페이징`  `페이지 테이블`  `PTBR`  `TLB`**

<aside>

외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문

메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 외부 단편화는 발생하지 않음

</aside>

### 페이징

> 메모리의 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법
> 
- 페이징에서도 스와핑 사용 가능
    - 프로세스 전체가 아닌 페이지 단위로 스왑 아웃 / 스왑 인이 이루어짐
    때문에 페이지 아웃 / 페이지 아웃이라고도 부름
    - 즉, 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요는 없다는 것
- 내부 단편화 문제를 야기할 수 있음
    - 내부 단편화 : 모든 프로세스 크기가 페이지의 배수는 아니기에 발생하는 메모리 낭비
    - ex) 페이지 크기가 10KB인데, 프로세스의 크기가 108KB인 경우 마지막 페이지는 2KB만큼의 크기가 남음(낭비됨)

<aside>

여기서 문제는 프로세스가 메모리에 불연속적으로 배치되어 있을 경우 CPU 입장에서 이를 순차적으로 실행할 수 없음 (다음에 실행할 명령어 위치를 찾기 어려워진다는 것)

이를 해결하기 위해 페이징 시스템은 프로세스가 물리 주소(실제 메모리 내의 주소)에 불연속적으로 배치되더라도 논리 주소(CPU가 바라보는 주소)에는 연속적으로 배치되도록 페이지 테이블을 이용

</aside>

### 페이지 테이블

> 페이지 번호를 이용해 페이지가 적재된 프레임을 찾을 수 있도록 하는 것
페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
> 

### 페이지 테이블 베이스 레지스터 (PTBR)

> 각 프로세스의 페이지 테이블이 적재된 주소
> 
- ex) 프로세스 A가 실행될 때 PTBR은 프로세스 A의 페이지 테이블을 가리키고, CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있음

### TLB

> 페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장하는 역할을 수행
> 
- 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다는 문제가 발생
- 때문에 TLB, 즉 페이지 테이블의 캐시를 이용해서 페이지 테이블의 일부 내용을 저장
- TLB 히트
    - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있는 경우
    - 이 경우에는 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없음
- TLB 미스
    - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 없는 경우
    - 이 경우에는 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근해야 함

### 페이징에서의 주소 변환

- 하나의 페이지 또는 프레임은 여러 주소를 포과하고 있기에 특정 주소에 접근하려면 두 가지 정보가 필요
    1. 어떤 페이지 또는 프레임에 접근하고 싶은지
    2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 때문에 페이징 시스템에서는 모든 논리 주소가 페이지 번호와 변위로 이루어져 있음
    - 변위 : 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보
- 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환

### 페이지 테이블 엔트리

> 페이지 테이블의 각각의 행동들
페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 참조 비트, 수정 비트 등의 정보가 담김
> 

### 유효 비트

> 해당 페이지에 접근 가능한 지 여부를 알려줌
즉, 페이지가 메모리에 적재되어 있는지, 보조기억장치에 있는지를 알려주는 비트
> 
- 페이지가 메모리에 적재되어 있는 경우 1, 적재되어 있지 않은 경우 0

### 페이지 폴트

> CPU가 유효 비트가 0인 페이지에 접근하려고 할 때 발생하는 예외
> 
- CPU가 페이지 폴트를 처리하는 과정
    1. CPU가 기존의 작업 내역을 백업
    2. 페이지 폴트 처리 루틴을 실행
    3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
    4. 페이지 폴트를 처리했다면 CPU가 해당 페이지로 접근 가능

### 보호 비트

> 페이지에 접근할 권한을 제한하여 페이지를 보호하는 비트
> 
- 한 개의 비트로 구현하는 경우
    - 읽고 쓰기가 모두 가능한 페이지인 경우 1, 읽기만 가능한 경우 0
- 세 개의 비트로 구현하는 경우
    - 읽기를 나타내는 r, 쓰기를 나타내는 w, 실행을 나타내는 x의 조합
    - ex) 100 : 읽기만 가능한 페이지
    - ex) 111 : 읽기, 쓰기, 실행이 모두 가능한 페이지

### 참조 비트

> CPU가 이 페이지에 접근한 적이 있는지 여부를 나타내는 비트
> 
- 적재 이후 CPU가 읽거나 쓴 페이지의 경우 1, 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지의 경우 0

### 수정 비트 (더티 비트)

> 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 나타내는 비트
> 
- 변경된 적이 있는 페이지의 경우 1, 변경된 적이 없는 페이지의 경우 0
- 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재
    - 수정된 적이 없는 페이지가 스왑 아웃될 경우 추가 작업 없이 새로 적재된 페이지로 덮어쓰기만 하면 됨
    - 수정된 적이 있는 페이지기 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가로 필요

## 3. 페이지 교체와 프레임 할당

**`요구 페이징`  `페이지 교체 알고리즘`  `스래싱`  `프레임 할당`**

### 요구 페이징

> 페이지가 필요할 때에만 메모리에 적재하는 기법
> 
1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. 해당 페이지의 유효 비트가 1일 경우 CPU는 페이지가 적재된 프레임에 접근
3. 유효 비트가 0일 경우 페이지 폴트가 발생
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정
5. 다시 1번 수행

### 순수 요구 페이징

> 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행하는 기법
> 
- 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하고, 실행에 필요한 페이지가 어느 정도 적재된 이우부터는 페이지 폴트 발생 빈도가 떨어짐

<aside>

요구 페이징 기법으로 페이지를 적재하다 보면 언젠가 메모리가 가득 차게 됨

이때 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 함

어떤 페이지를 쫓아낼 지 결정하는 방법을 **페이지 교체 알고리즘**이라 함

</aside>

### 페이지 교체 알고리즘

- 일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가
- 때문에 페이지 교체 알고리즘을 제대로 이해하려면 페이지 폴트 횟수를 알아야 함
- 페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있음
    - 페이지 참조열 : CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열
    - ex) CPU가 접근한 페이지 순서가 2 2 2 3 5 5 5 3 3 7인 경우 페이지 참조열은 2 3 5 3 7
    - 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않음

### FIFO 페이지 교체 알고리즘

> 메모리에 가장 먼저 올라온 페이지부터 내쫒는 방식
> 
- 장점
    - 구현이 간단
- 단점
    - 프로그램 실행 내내 사용될 내용을 내쫒을 수도 있음

### 2차 기회 페이지 교체 알고리즘

> FIFO 페이지 교체 알고리즘의 변형
메모리에 가장 오래 머물렀던 페이지의 참조 비트가 1일 경우, 당장 내쫓지 않고 참조 비트를 0으로 만든 뒤 현재 시간을 적재 시간을 0으로 설정하는 것
즉, 참조 비트가 1인 경우 내쫓지 않고 가장 최근에 적재한 페이지로 만드는 것
> 

### 최적 페이지 교체 알고리즘

> 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
> 
- 장점
    - 가장 낮은 페이지 폴트율을 보장하는 알고리즘
- 단점
    - 구현이 어려움
    - 앞으로 오랫동안 사용되지 않을 페이지를 예측하기 어려움
- 단점 때문에 운영체제에서 사용하기 보다는, 주로 이론 상 성능을 평가하기 위한 목적으로 사용

### LRU 페이지 교체 알고리즘

> 최적 페이지 교체 알고리즘의 변형
가장 오랫동안 사용되지 **않은** 페이지를 교체하는 알고리즘
(최적 페이지 교체 알고리즘은 가장 오랫동안 사용되지 **않을** 페이지를 교체하는 알고리즘)
> 

<aside>

페이지 폴트가 자주 발생하는 이유

- 나쁜 페이지 교체 알고리즘
- 프로세스가 사용할 수 있는 프레임 수가 적은 경우 (더 근본적인 이유)
</aside>

### 스래싱

> 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저하되는 문제
> 
- 멀티프로그래밍의 정도 : 메모리에서 동시 실행되는 프로세스의 수
- 스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문

<aside>

운영체제는 각 프로세들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 함

</aside>

### 프레임 할당 방식

- 정적 할당 방식 : 프로세스 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만 고려한 방식
    - 균등 할당 : 모든 프로세스에 동일한 프레임을 배분하는 방식
        - 실행되는 프로세스들의 크기가 각기 다르기 때문에 권장하지 않음
    - 비례 할당 : 프로세스 크기에 따라 프레임을 배분하는 방식
        - 프로세스의 크기가 클지라도 막상 실행해 보니 많은 프레임을 필요로 하지 않는 경우도 존재하기 때문에 완벽한 방식은 아님
- 동적 할당 방식 : 프로세스의 실행을 보고 할당할 프레임 수를 결정하는 방식
    - 작업 집합 모델을 사용하는 방식
        - 작업 집합 : 실행 중인 프로세스가 일정 시간 동안 페이지의 집합
        - 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지
    - 페이지 폴트 빈도를 사용하는 방식
        - 가정
            1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 가지고 있음을 의미
            2. 페이지 폴트율일 너무 낮으면 그 프로세스는 너무 많은 프레임을 가지고 있음을 의미
        - 페이지 폴트율의 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식