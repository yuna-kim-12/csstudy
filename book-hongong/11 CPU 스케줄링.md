<aside>

**CPU 스케줄링 요약**

- CPU 스케줄링은 공정하고 합리적으로 CPU 자원을 배분하는 방법을 의미합니다.
- CPU 스케줄링은 **언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업**
- 프로세스는 우선순위를 가지고 있고, 이는 PCB에 명시됩니다.
- 운영체제는 효율적인 스케줄링을 위해 스케줄링 큐를 사용합니다.
- 준비 큐는 CPU 할당을 기다리는 프로세스들을 위한 큐를 의미합니다.
- 대기 큐는 입출력장치를 기다리는 프로세스들을 위한 큐를 의미합니다.
- 선점형 스케줄링은 프로세스가 이용 중인 자원을 빼앗을 수 있습니다.
- 비선점형 스케줄링은 프로세스가 이용 중인 자원을 빼앗을 수 없습니다.

**스케줄링 알고리즘 요약**

- 선입 선처리 스케줄링 알고리즘은 준비 큐에 삽입된 순서대로 CPU를 할당합니다.
- 최단 작업 우선 스케줄링 알고리즘은 준비 큐에 삽입된 프로세스들 중 CPU 사용 시간의 길이가 가장 짧은 프로세스부터 CPU를 할당합니다.
- 라운드 로빈 스케줄링 알고리즘은 정해진 시간만큼만 돌아가며 CPU를 할당합니다.
- 우선순위 스케줄링 알고리즘은 가장 높은 우선순위를 가진 프로세스에 CPU를 할당합니다.
- 다단계 피드백 큐 스케줄링 알고리즘은 프로세스들이 큐 사이를 이동할 수 있는 다단계 큐 스케줄링입니다.
</aside>

# 1. 개요

- CPU 스케줄링
    - 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
    - 컴퓨터 성능과 직결되는 중요한 문제

## 1. 프로세스 우선 순위

---

- 프로세스의 우선순위에 따라 CPU 스케줄링 진행
- 프로세스의 종류에 따라 우선순위 결정.
    - 대표적으로 우선순위가 높은 프로세스 : 입출력 작업이 많은 프로세스, 실시간 프로세스, 일부 백그라운드 프로세스

<aside>

**일반적인 프로세스 실행 과정**

![alt text](<image/11-1 process.png>)

- CPU와 입출력 장치를 모두 사용해, 실행 상태와 대기 상태를 반복하며 실행
- 즉, **프로세스 실행은 CPU 실행과 I/O 대기 사이클로 구성된다.**

**용어**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/e80a8944-ffa4-433c-a046-653ae8b3ff10/image.png)

- CPU 버스트(CPU burst) : CPU를 이용하는 작업
- 입출력 버스트(I/O burst) : 입출력 장치를 기다리는 작업
    
    ⇒ 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행
    
</aside>

### 1. 프로세스의 종류

1. **입출력 집중 프로세스(I/O bound process)**
    - 입출력 버스트 > CPU 버스트
    - e.g. 비디오 재생, 디스크 백업
    - 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무르게 됨
    
2. **CPU 집중 프로세스(CPU bound process)**
    - 입출력 버스트 < CPU 버스트
    - e.g. 수학 연산, 컴파일, 그래픽 처리 작업
    - 실행 상태에 많이 머무르게 됨

⇒ 입출력 집중 프로세스를 빨리 실행시켜 입출력장치를 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 효율적.

입출력 장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 대기 상태가 될 예정이므로, 이를 먼저 처리하면 다른 프로세스가 CPU를 사용 가능.

### 2. 우선순위 Priority

- 프로세스의 중요도와 상황에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위를 부여함.
- 운영체제는 각 프로세스의 PCB에 우선순위를 명시하며, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정함.
    
    <aside>
    
    - **PCB(Process Control Block)**
        - 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체
        - 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요
            - **Context Switching :** CPU가 현재 작업중인 프로세스에서 다른 프로세스로 넘어갈 때, 이전의 프로세스 정보를 PCB에 저장하고 새롭게 실행할 프로세스의 정보를 PCB에서 읽어와 레지스터에 적재하는 과정
        - PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지
        - https://dev-mystory.tistory.com/119
    </aside>
    

<aside>

**프로세스 우선순위 확인하기**

- 유닉스 체계 운영체제(유닉스, 리눅스, macOS)
    - ps -el 명령 : 프로세스 우선순위 확인 가능
    - nice  명령  : 일부 프로세스 우선순위 변경
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/800a9210-a176-4b05-80d9-edf38a977d4f/image.png)
    
- 윈도우 운영체제
    - Process Explorer 소프트웨어로 확인, 변경
</aside>

## 2. 스케줄링 큐 Scheduling queue

---

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/9ae36595-535f-45f9-83bd-be4092aa4197/image.png)

- 운영체제는 메모리/CPU/입출력장치를 이용하는 프로세스들을 각각 큐에 삽입해 관리

### 스케줄링 큐의 종류

- 자료구조인 큐는 선입선출 방식이나, 스케줄링 큐는 반드시 선입선출 방식일 필요는 없음. 우선순위에 따라 실행 순서가 변경 가능함.
1. **준비 큐  ready queue**
    - CPU를 이용하고 싶어하는 프로세스가 삽입되는 줄
    - 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되며, 운영체제는 PCB가 큐에 삽입된 순서대로 프로세스를 하나 씩 실행하되 그중 우선순위가 높은 프로세스를 먼저 실행.
    
2. **대기 큐 waiting queue**
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/7f748afd-c9c6-4dc3-a47a-a040a1aa0b14/image.png)
    
    - 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스가 삽입되는 줄
    - 같은 장치를 요구한 프로세스는 같은 대기 큐에서 입출력이 완료되기를 기다리게 됨.
    이후, 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거 후 준비큐로 이동함.
        - **인터럽트 (Interrupt)**
            - CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능
            - 어느 시점에서건 일어날 수 있고, 커널에 의해서 항상 무시될 수는 없기 때문에, 인터럽트에 의해서 영향을 받는 코드 부분은 반드시 **동시 사용으로부터 보호되어야 한다.**

## 3. 선점형과 비선점형 스케줄링

---

**현재 대부분의 운영체제는 선점형 스케줄링 방식을 차용하고 있음.**

### 1. 선점형 스케줄링 preemptive scheduling

- 프로세스가 CPU를 비롯한 자원을 사용중이더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당 가능한 스케줄링 방식
- 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
- 장점 : 어느 한 프로세스의 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있음
- 단점 : 문맥 교환 과정에서 오버헤드 발생 가능
    - **오버헤드 (Overhead)**
        - 어떤 일을 처리할 때 추가적으로 소모된 자원
        - 예를 들어 , 프로그램의 실행 흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때 , 추가적으로 시간, 메모리, 자원이 사용되는 현상

### 2. 비선점형 스케줄링 non-preemptive scheduling

- 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식.
- 하나의 프로세스가 자원 사용을 독점
- 장점 : 문맥 교환에서 발생하는 오버헤드가 선점형 스케줄링보다 적음
- 단점 : 모든 프로세스가 골고루 자원을 사용할 수 없음

# 2. 스케줄링 알고리즘

- 스케줄링 알고리즘 종류는 매우 다양하고, 운영체제마다 서로 다른 스케줄링 알고리즘을 사용하고 있음
    
    ⇒ 각 스케줄링 알고리즘의 작동 방식과 장단점을 **이해**하는 방식으로 학습
    

### 1. 선입 선처리/FCFS 스케줄링 First Come First Schduling

---

- 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식
- CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식
- 장점 : 단순하고 구현이 쉬움
- 단점 : **호위 효과 convoy effext**
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/81c9526e-2a82-450e-9b75-dab470179efd/image.png)
    
    - **실행 시간이 긴 프로세스 하나가 CPU를 점유하고 있을 때, 실행 시간이 짧은 여러 프로세스들이 그 뒤에서 계속 대기해야 하는 현상**. 마치 도로에서 느리게 주행하는 트럭 한 대가 길을 막고 있으면, 그 뒤에 빠르게 달릴 수 있는 차들이 줄지어 서행해야 하는 상황과 유사하다고 하여 '호위 효과'라는 이름이 붙음. 호위효과가 발생할 경우 CPU와 장치 이용률이 낮아진다.
    - **평균 대기 시간 증가:** 실행 시간이 짧은 프로세스들이 긴 프로세스 뒤에서 불필요하게 오래 대기하게 되므로, 시스템 전체의 평균 대기 시간이 증가
    - **CPU 이용률 저하:** 대기 중인 프로세스들이 CPU를 사용할 수 없기 때문에, CPU 이용률이 저하
    - **시스템 응답 시간 저하:** 사용자가 요청한 작업이 빠르게 처리되지 못하고 지연되므로, 시스템의 응답 시간이 느려짐.

⇒ 호위 효과는 CPU 스케줄링에서 비효율을 초래하는 중요한 문제이며, 이를 해결하기 위해 다양한 스케줄링 기법들이 연구되고 적용

### 2. 최단 작업 우선/SJF 스케줄링 Shortest Job First Scheduling

---

- 준비 큐에 삽입된 프로세스 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식. 기본적으로 비선점형 스케줄링 알고리즘으로 분류되나, 선점형으로도 구현 가능

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/ff90206e-7173-4bba-a3d7-cd213627ae24/image.png)

### 3. 라운드 로빈 스케줄링 round robin scheduling

---

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/2c8eae55-9de9-4119-ad52-a7c459b65242/image.png)

- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링(선입선처리+타임슬라이스)
    - 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 큐에 삽입된 프로세스들은 삽입된 순서대로 CPU를 이용하되 정해진 시간만큼만 CPU를 사용하고, 정해진 시간을 모두 사용했지만 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입.
- 적절한 타임 슬라이스 크기를 설정하는 것이 중요.
    - 타임 슬라이스가 지나치게 크면 사실상 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 타임 슬라이스가 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전 환하는 데에 온 힘을 다 쓸 여지가 있기 때문.

### 4. 최소 잔여 시간 우선/SRT 스케줄링 Shortest Remaining Time

---

- 프로세스는 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택(최단 작업 우선 스케줄링 + 라운드 로빈 알고리즘)

### 5. 우선순위 스케줄링 priority scheduling

---

- 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘(우선순위가 같을 경우 선입 선처리로 스케줄링)
- 단점 : **기아 현상(starvation)** 발생
    - **여러 프로세스가 자원을 공유하는 환경에서, 특정 프로세스가 자원을 할당받지 못하고 무한정 대기하는 현상**. 이는 마치 굶주림(Starvation)과 같다고 하여 붙여진 이름. 주로 우선순위가 낮은 프로세스에서 발생하기 쉽지만, 시스템 상황에 따라 우선순위가 높은 프로세스에서도 발생 가능함.
- 기아 현상 방지를 위한 기법 : 에이징(aging_
    - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식. 이를 통해, 장시간 대기한 프로세스도 언젠가는 자원을 할당받을 수 있도록 보장.

### 6. 다단계 큐 스케줄링 multilevel queue scheduling

---

- **우선순위 스케줄링이 라운드 로빈과 결합**
- 우선순위 별로 큐를 여러 개 사용하는 스케줄링 방식으로, 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선 순위가 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리
- 프로세스 유형 별로 우선순위를 구분해 실행하는 것이 편리해지며, 큐 별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있음.

### 7. 다단계 피드백 큐 스케줄링 mutilevel feedback queue scheduling

---

- 기아 현생이 발생할 수 있는 다단계 큐 스케줄링을 보완한 알고리즘으로, 프로레스들이 큐 사이를 이동할 수 있다는 차이점이 있음.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/a4909d84-4be2-4e4a-8192-01dc46d8791d/cf497481-c136-4683-ab57-4aa354b1add2/image.png)

- 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키되, 낮은 우선순위 큐에서 오래 기다리고 있는 프로세스가 있다면 점자 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용해 기아 현상을 예방
- 구현이 복잡하지만 가장 일반적인 CPU 스케줄링 알고리즘임