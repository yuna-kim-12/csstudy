# Chapter 4  CPU의 동작원리

### Q1. ALU는 계산 결과 외에 어떤 정보를 추가적으로 제공하며, 그것의 역할은 무엇인가요?
<details>
<summary>A1.</summary>
<div markdown="1">
    ALU는 계산 결과 외에도 플래그를 제공합니다. 플래그는 연산 결과에 대한 추가적인 상태 정보를 나타내며, 이는 제어장치가 명령어의 흐름을 제어하거나 연산 후 추가 작업 여부를 판단할 때 활용됩니다.
</div>
</details>

### Q2. 인터럽트의 종류에는 무엇이 있으며, 각각의 특징은 무엇인가요?
<details>
<summary>A2.</summary>
<div markdown="1">
    인터럽트는 동기 인터럽트와 비동기 인터럽트로 나뉩니다.
    
    - 동기 인터럽트: CPU에서 발생하며, 주로 연산 오류와 같은 상황에서 발생합니다. 이를 예외라고도 부릅니다.
    - 비동기 인터럽트: 입출력 장치에서 발생하며, 키보드나 마우스 입력과 같은 하드웨어 신호에 의해 생성됩니다. 이를 하드웨어 인터럽트라고도 부릅니다.
</div>
</details>
    
### Q3. 스택 주소 지정 방식과 변위 주소 지정 방식의 차이점은 무엇인가요?
<details>
<summary>A3.</summary>
<div markdown="1">

    - 스택 주소 지정 방식은 스택과 스택 포인터를 이용하여 유효 주소를 설정하는 방식입니다. 가장 최근에 저장된 데이터를 먼저 꺼내는 구조로 동작하며, 스택 포인터가 스택의 꼭대기를 가리킵니다.

    - 변위 주소 지정 방식은 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻는 방식입니다. 상대 주소 지정 방식(프로그램 카운터 사용)과 베이스 레지스터 주소 지정 방식(베이스 레지스터 사용)으로 세분화됩니다.
    
</div>
</details>



## ALU와 제어장치

### ALU

- 레지스터를 통해 피연산자를 받아드리고, 제어장치로부터 제어 신호를 받아드린다
- ALU가 내보내는 결과값은 바로 메모리에 저장되지 않고, 일시적으로 레지스터에 저장된다
    - CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느리기 때문이다. 따라서 속도를 빠르게 하기 위해, 레지스터에 우선 저장한다.
- ALU는 계산 결과와 더불에 **플래그**를 내보낸다
- **플래그**: 연산 결과에 대한 추가적인 상태 정보
- **오버플로우**: 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황

- 플래그들은 **플래그 레지스터**라는 레지스터에 저장된다

![image.png](image/4-1.png)

### 제어 장치

- 제어 신호를 내보내고, 명령어를 해석하는 장치이다.
- 첫째, 제어 장치는 클럭 신호를 받아드린다
    - **클럭**: 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
- 둘째, 제어장치는 ‘해석해야 할 명령어’를 받아들인다
- 셋째, 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다
- 넷째, 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아드린다

![image.png](image/4-2.png)

## 레지스터

1. 프로그램 카운터
    1. 메모리에서 읽어 드릴 명령어의 주소를 저장한다
    2. 프로그램 카운터를 **명령어 포인터** 라고 부르는 CPU도 있다
2. 명령어 레지스터
    1. 방금 메모리에서 읽어 드린 명령어를 저장하는 레지스터
    2. 명령어 레지스터 속 명령어를 받아드리고 해석한 뒤, 제어 신호를 내보낸다
3. 메모리 주소 레지스터
    1. 메모리의 주소를 저장하는 레지스터
    2. CPU가 주소 값을 주소 버스로 보낼 때, 메모리 주소 레지스터를 거치게 된다
4. 메모리 버퍼 레지스터
    1. 메모리와 주고받을 값을 저장하는 레지스터
    2. CPU가
    3. **메모리 데이터 레지스터**라고도 부른다
5. 플래그 레지스터
    1. 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터
6. 범용 레지스터
    1. 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
    2. 데이터와 주소를 모두 저장할 수 있는 특징이 있다
7. 스택 포인터
8. 베이스 레지스터

### 특정 레지스터를 이용한 주소 지정 방식: 스택 주소 지정 방식

- 스택과 스택 포인터를 이용한 주소 지정 방식이다
    - **스택**: 한쪽 끝이 막혀있는 통로 같은 저장공간, 가장 최근에 저장하는 값부터 꺼낼 수 있다
    - **스택 포인터**: 스택의 꼭대기를 가리키는 레지스터

### 특정 레지스터를 이용한 주소 지정 방식: 변위 주소 지정 방식

- 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다
- 변위 주소 지정 방식을 사용하는 명령어는 **연산 코드 필드**, **레지스터 필드**, **오퍼랜드 필드**가 있다.
- 변위 주소 지정 방식은 **상대 주소 지정 방식**, **베이스 레지스터 주소 지정 방식** 등으로 나뉜다.
    - **상대 주소 지정 방식**: 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
    - **베이스 레지스터 주소 지정 방식**: 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

## 명령어 사이클과 인터럽트

- **명령어 사이클**: 하나의 명령을 처리하는 정형화된 흐름
- **인터럽트**: 정해진 흐름에 따라 명령어를 처리해 나가는 과정이 끊어지는 상황

### 명령어 사이클

- 프로그램 속 각각의 명령어들이 반복되며 실행되는 주기를 뜻한다
    - 인출 사이클: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
    - 실행 사이클: CPU로 가져온 명령어를 실행하는 단계

![image.png](image/4-3.png)

- 모든 명령어가 위 그림처럼 간단히 실행되는 것은 아님!
    - ex) 간접 주소 지정 방식은 명령어를 CPU로 가져왔다 하더라도 바로 실행 사이클로 갈 수 없다.
    - 따라서 명령어를 실행하기 위해 메모리 접근을 한 번 더 해야 하고 이를 **간접 사이클**이라고 한다.
    
    ![image.png](image/4-4.png)
    

### 인터럽트

- CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있다.
- 이렇게 CPU의 작업을 방해하는 신호를 **인터럽트**라고 한다.
- 인터럽트의 종류에는 **동기 인터럽트**와 **비동기 인터럽트**가 있다.

### 동기 인터럽트

- CPU에 의해 발생하는 인터럽트
- CPU가 명령어들을 수행하다가 오류와 같은 상황에 마주쳤을 때 발생한다.
- 동기 인터럽트는 **예외**라고 부른다.

### 비동기 인터럽트

- 입출력장치에 의해 발생하는 인터럽트이다.
- 키보드, 마우스와 같은 입출력 장치들이 어떠한 입력을 받았을 때, 이를 처리하기 위해 CPU에 인터럽트를 보내는 것이다.
- **하드웨어 인터럽트**라고 불린다.

### 하드웨어 인터럽트(비동기 인터럽트)

- CPU가 입출력 작업 도중 효율적으로 명령어를 처리하기 위해 사용한다.
- 하드웨어 인터럽트를 사용하게 되면 CPU는 주기적으로 입출력장치의 작업 완료 여부를 확인하지 않아도 된다.
- 따라서 CPU 사이클 낭비를 없앨 수 있다.

### 하드웨어 인터럽트 처리 순서

1. 입력장치는 CPU에 **인터럽트 요청 신호**를 보냅니다.
    1. **인터럽트 요청 신호**: 입출력장치가 CPU에게 실행 흐름을 끊어도 되는지 물어보는 신호
    
    ![image.png](image/4-5.png)
    
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인합니다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인합니다.
    1. **인터럽트 플래그**: 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 플래그
    2. CPU가 중요한 작업을 처리해야 하면, 인터럽트 플래그는 불가능으로  설정되고 CPU는 인터럽트 요청이 오더라도 해당 요청을 무시한다.
    
    ![image.png](image/4-6.png)
    
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업합니다.
    1. 인터럽트 요청을 받아들이기로 했다면, 인터럽트 서비스 루틴이라는 프로그램을 실행한다.
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행합니다.
    1. **인터럽트 서비스 루틴**: 인터럽트를 처리하기 위한 프로그램이다. 즉, 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다.
    
        
        ![image.png](image/4-7.png)
        
    2. **인터럽트 벡터**: 인터럽트 서비스 루틴을 식별하기 위한 정보이다.
        1. 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다.
            
            ![image.png](image/4-8.png)
            
6. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개합니다.

## 예외의 종류

- 예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다.

### 폴트

- 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외이다.

### 트랩

- 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외이다.
- 주로 디버깅할 때 사용된다.

### 중단

- CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외이다.